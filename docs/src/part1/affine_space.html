<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>1&nbsp; 아핀 기하학 – 기하학</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../src/references.html" rel="next">
<link href="../../src/part1/part1.html" rel="prev">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-b467865d89f01302b3bb45791fa41ab5.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "일치 없음",
    "search-matching-documents-text": "일치된 문서",
    "search-copy-link-title": "검색 링크 복사",
    "search-hide-matches-text": "추가 검색 결과 숨기기",
    "search-more-match-text": "추가 검색결과",
    "search-more-matches-text": "추가 검색결과",
    "search-clear-button-title": "제거",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "취소",
    "search-submit-button-title": "검색",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="사이드바 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../src/part1/part1.html">기하학</a></li><li class="breadcrumb-item"><a href="../../src/part1/affine_space.html"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">아핀 기하학</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="사이드바 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../src/part1/part1.html">기하학</a></li><li class="breadcrumb-item"><a href="../../src/part1/affine_space.html"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">아핀 기하학</span></a></li></ol></nav>
      <h1 class="title"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">아핀 기하학</span></h1>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../../">기하학</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../../src/part1/part1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">기하학</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="토글 섹션">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/part1/affine_space.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">아핀 기하학</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">references.html</span></span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">목차</h2>
   
  <ul>
  <li><a href="#아핀-공간의-정의와-성질" id="toc-아핀-공간의-정의와-성질" class="nav-link active" data-scroll-target="#아핀-공간의-정의와-성질"><span class="header-section-number">1.1</span> 아핀 공간의 정의와 성질</a>
  <ul class="collapse">
  <li><a href="#sec-AG_affine_space" id="toc-sec-AG_affine_space" class="nav-link" data-scroll-target="#sec-AG_affine_space"><span class="header-section-number">1.1.1</span> 아핀 공간의 정의와 기본적 성질</a></li>
  <li><a href="#sec-AG_vectorization_and_subspace" id="toc-sec-AG_vectorization_and_subspace" class="nav-link" data-scroll-target="#sec-AG_vectorization_and_subspace"><span class="header-section-number">1.1.2</span> 아핀 공간의 벡터 공간화와 아핀 부분공간</a></li>
  <li><a href="#sec-AG_set_properties_of_affine_space" id="toc-sec-AG_set_properties_of_affine_space" class="nav-link" data-scroll-target="#sec-AG_set_properties_of_affine_space"><span class="header-section-number">1.1.3</span> 아핀 공간의 집합적 성질</a></li>
  <li><a href="#sec-AG_paralleism" id="toc-sec-AG_paralleism" class="nav-link" data-scroll-target="#sec-AG_paralleism"><span class="header-section-number">1.1.4</span> 아핀공간의 평행</a></li>
  </ul></li>
  <li><a href="#아핀-사상" id="toc-아핀-사상" class="nav-link" data-scroll-target="#아핀-사상"><span class="header-section-number">1.2</span> 아핀 사상</a>
  <ul class="collapse">
  <li><a href="#sec-AG_affine_map" id="toc-sec-AG_affine_map" class="nav-link" data-scroll-target="#sec-AG_affine_map"><span class="header-section-number">1.2.1</span> 아핀 사상</a></li>
  </ul></li>
  <li><a href="#연습문제" id="toc-연습문제" class="nav-link" data-scroll-target="#연습문제">연습문제</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<div class="hidden">
<p>% %</p>
%
<p><span class="math display">\[
\DeclarePairedDelimiters{\set}{\{}{\}}
\DeclareMathOperator*{\argmax}{argmax}
\]</span></p>
</div>
<p>곡선과 표면은 일반적으로 점들(points)로 구성된 공간에 존재하는 특별한 속성을 가진 점들의 집합으로 간주된다. 일반적으로 translations, rotations, projections 등과 같은 특정 변환 하에서 불변하는 기하학적 특성이 중요하다. 점으로 이루어진 공간을 소위 벡터 공간으로 모델링할 수 있지만 이는 여러 가지 이유로 그다지 만족스럽지 않다. 한 가지 중요한 이유는 원점이라고 불리는 영벡터에 해당하는 점이 실제로 특권을 가질 이유가 없음에도 특별한 역할을 하기 때문이다. 또 다른 이유는 parallelism 과 같은 특정 개념이 어색한 방식으로 처리된다는 것이다. 그러나 더 중요 한 이유는 벡터 공간과 아핀 공간이 실제로 다른 기하학적 구조를 가지고 있다는 것이다. 벡터 공간의 기하학적 속성은 동형사상에 대해 불변인 반면, 아핀 공간의 기하학적 속성은 전단사 아핀 사상 그룹에서 불변하며 이 두 그룹은 동형이 아니다. 대략적으로 말하면 선형 맵보다 아핀 맵이 더 많다.</p>
<p>아핀 공간은 기하학을 수행하기 위한 더 나은 틀을 제공한다. 특히 점, 곡선, 표면 등을 본질적인 방식, 즉 특정 좌표계의 선택과 관계없이 처리하는 것이 가능하다. 물리학에서와 마찬가지로 이것은 실제로 무슨 일이 일어나고 있는지 이해하는 데 매우 바람하다. 물론 최종적으로 계산을 수행하려면 좌표계를 선택해야 하지만 실제로 필요할 때까지는 좌표계에 의존하려는 유혹을 물리치는 법을 배워야 한다. 아핀 공간은 무엇보다도 움직임, 궤적, 물리적 힘을 다루는 데 적합하다. 따라서 아핀 기하학은 운동학, 역학 및 기타 물리학 부분(예: 탄성)을 깔끔하게 표현하는 데 매우 중요하게 된다.</p>
<p><br></p>
<section id="아핀-공간의-정의와-성질" class="level2" data-number="1.1">
<h2 data-number="1.1" class="anchored" data-anchor-id="아핀-공간의-정의와-성질"><span class="header-section-number">1.1</span> 아핀 공간의 정의와 성질</h2>
<section id="sec-AG_affine_space" class="level3" data-number="1.1.1">
<h3 data-number="1.1.1" class="anchored" data-anchor-id="sec-AG_affine_space"><span class="header-section-number">1.1.1</span> 아핀 공간의 정의와 기본적 성질</h3>
<p>벡터를 다룰 때 벡터 공간을 정의하는 것처럼 아핀 공간을 정의하자. 아핀 공간은 어떤 벡터 공간에 대해 정의하는 것이 가장 깔끔하다. 아핀 공간에 대해 여러가지 동등한 정의가 존재하지만 다음의 정의를 따른다.</p>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div id="def-AG_affine_space" class="theorem definition">
<p><span class="theorem-title"><strong>정의 1.1 (아핀 공간)</strong></span> 집합 <span class="math inline">\(\mathcal{E}\)</span> 가 <span class="math inline">\(\mathbb{F}\)</span>-벡터 공간 <span class="math inline">\(E\)</span> 와 함수 <span class="math inline">\(\Theta : \mathcal{E} \times \mathcal{E} \to E\)</span> 에 대해 아래의 성질을 만족하면 아핀 구조가 부여되었다고 아핀구조가 부여된 집합을 <strong>아핀 공간(affine space)</strong> 라고 한다.</p>
<p> (<span class="math inline">\(1\)</span>) 임의의 고정된 <span class="math inline">\(A\in \mathcal{E}\)</span> 에 대해 <span class="math inline">\(\Theta_A(B) = \Theta(A,\,B)\)</span> 는 <span class="math inline">\(\mathcal{E}\mapsto E\)</span> 인 전단사 함수이다.</p>
<p> (<span class="math inline">\(2\)</span>) <strong>샬 관계(Chasles’ relation)</strong>: 각각의 <span class="math inline">\(A,\,B,\,C\in \mathcal{E}\)</span> 에 대해 <span class="math inline">\(\Theta (A,\,C) + \Theta(C,\,B) = \Theta(A, B)\)</span> 이다.</p>
<p>이 때 아핀 공간 <span class="math inline">\(\mathcal{E}\)</span> 를 <span class="math inline">\(\langle \mathcal{E},\, E,\,\Theta\rangle\)</span> 혹은 <span class="math inline">\(\mathcal{E}(E,\,\Theta)\)</span> 로 표현하며 <span class="math inline">\(E\)</span> 를 <span class="math inline">\(\mathcal{E}\)</span> 의 <strong>방향(direction)</strong> 혹은 <span class="math inline">\(\mathcal{E}\)</span> 에 <strong>내재된 벡터 공간 (underlying vector space)</strong> 라고 하고 <span class="math inline">\(\mathcal{E}\)</span> 는 <span class="math inline">\(E\)</span> 를 <strong>내포한다</strong> 고 한다. <span class="math inline">\(\mathcal{E}\)</span> 의 원소를 <strong>점(point)</strong> 이라고 하며 벡터 공간 <span class="math inline">\(E\)</span> 의 차원을 <span class="math inline">\(\mathcal{E}\)</span> 의 차원 이라고 하고 <span class="math inline">\(\dim(\mathcal{E})\)</span> 라고 표기한다. 그리고 <span class="math inline">\(\Theta (A,\,B)\)</span> 를 <span class="math inline">\(\overrightarrow{AB}\)</span> 로 쓴다.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<div id="fig-affine_space_and_vector_space" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-affine_space_and_vector_space-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/affinespace_and_vectorspace.png" class="img-fluid figure-img" width="550">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-affine_space_and_vector_space-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
그림&nbsp;1.1: 아핀 공간과 벡터 공간
</figcaption>
</figure>
</div>
<p><br></p>
<div class="border" style="background-color:#FFF0F5 ;padding:5px;">
<div id="prp-AG_affile_space_1" class="theorem proposition">
<p><span class="theorem-title"><strong>명제 1.1</strong></span> <span class="math inline">\(\Theta(A, A)=\overrightarrow{AA}=\overrightarrow{0}\)</span> 이다. 또한 <span class="math inline">\(\overrightarrow{AB}=-\overrightarrow{BA}\)</span> 이다.</p>
</div>
</div>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span><span class="math inline">\(A=B=C\)</span> 라 놓으면 <span class="math inline">\(\overrightarrow{AA}=\overrightarrow{0}\)</span> 임을 보일 수 있다. <span class="math inline">\(\overrightarrow{AB}+\overrightarrow{BC}=\overrightarrow{AC}\)</span> 에서 <span class="math inline">\(C=A\)</span> 로 놓으면 <span class="math inline">\(\overrightarrow{AB}+\overrightarrow{BA}= \overrightarrow{AA}=\overrightarrow{0}\)</span> 이므로 <span class="math inline">\(\overrightarrow{AB}= - \overrightarrow{BA}\)</span> 이다. <span class="math inline">\(\square\)</span></p>
</div>
<p><br></p>
<div class="border" style="background-color:#FFF0F5 ;padding:5px;">
<div id="prp-AG_affile_space_2" class="theorem proposition">
<p><span class="theorem-title"><strong>명제 1.2</strong></span> 아핀 공간 <span class="math inline">\(\mathcal{E}(E,\,\Theta)\)</span> 와 임의의 <span class="math inline">\(A\in \mathcal{E}\)</span> 에 대해 <span class="math inline">\(\Theta_A(\mathcal{E})=E\)</span> 이다.</p>
</div>
</div>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span><a href="#def-AG_affine_space" class="quarto-xref">정의&nbsp;<span>1.1</span></a> 의 (<span class="math inline">\(1\)</span>). <span class="math inline">\(\square\)</span></p>
</div>
<p><br></p>
<div class="border" style="background-color:#FFF0F5 ;padding:5px;">
<div id="prp-AG_affile_space_3" class="theorem proposition">
<p><span class="theorem-title"><strong>명제 1.3</strong></span> 아핀 공간 <span class="math inline">\(\mathcal{E}(E,\,\Theta)\)</span> 에 대해 <span class="math inline">\(X\in \mathcal{E}\)</span> 일 필요충분조건은 임의의 <span class="math inline">\(A\in \mathcal{E}\)</span> 에 대해 <span class="math inline">\(\overrightarrow{AX}\in E\)</span> 인 것이다.</p>
</div>
</div>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span><span class="math inline">\(X\in \mathcal{E}\)</span> 라면 임의의 <span class="math inline">\(A\in \mathcal{E}\)</span> 에 대해 <span class="math inline">\(\Theta_A(X)=\overrightarrow{AX} \in E\)</span> 이다. <span class="math inline">\(A\in \mathcal{E}\)</span> 에 대해 <span class="math inline">\(\overrightarrow{AX}=\Theta_A(X)\in E\)</span> 라면 <span class="math inline">\(\Theta_A\)</span> 는 전단사이므로 <span class="math inline">\(X\in \mathcal{E}\)</span> 이다. <span class="math inline">\(\square\)</span></p>
</div>
<p><br></p>
<p>이제 아핀 공간을 이해하기 위해 몇가지 예를 들어 보자.</p>
<div class="border" style="background-color:#F2F4F4  ;padding:5px;">
<div id="exm-AG_affine_space_0" class="theorem example">
<p><span class="theorem-title"><strong>보기 1.1</strong></span> 공집합은 임의의 벡터 공간에 대해 아핀 공간이며 차원이 없는 것으로 간주한다.</p>
</div>
</div>
<br>
<div class="border" style="background-color:#F2F4F4  ;padding:5px;">
<div id="exm-AG_affine_space_1" class="theorem example">
<p><span class="theorem-title"><strong>보기 1.2 (벡터 공간의 아핀 구조)</strong></span> 벡터공간 <span class="math inline">\(V\)</span> 에 <span class="math inline">\(\theta : V \times V \to V\)</span> 를 <span class="math inline">\(\theta(u,\,v) := v-u\)</span> 로 정의하면 <span class="math inline">\(V(V,\,\theta)\)</span> 는 아핀공간임을 보이자.</p>
<p> (<span class="math inline">\(1\)</span>) 정해진 <span class="math inline">\(u\)</span> 에 대해 <span class="math inline">\(\theta_u(v)=\theta(u,\,v)\)</span> 라고 하면 <span class="math inline">\(\theta_u\)</span> 는 전단사이며,</p>
<p> (<span class="math inline">\(2\)</span>) <span class="math inline">\(\theta(u,\,v) + \theta(v,\,w) = v-u + w-v = \theta(u,\,w)\)</span> 이다.</p>
<p>즉 <span class="math inline">\(V(V,\,\theta)\)</span> 는 아핀공간이며 모든 벡터 공간에는 자연스러운 아핀 구조가 내재되어 있으며 벡터 공간 자체를 아핀 공간으로 간주 할 수 있다.</p>
</div>
</div>
<p><br></p>
<div class="border" style="background-color:#F2F4F4  ;padding:5px;">
<div id="exm-AG_affine_space_2" class="theorem example">
<p><span class="theorem-title"><strong>보기 1.3</strong></span> 벡터 공간 <span class="math inline">\(E_1,\,E_2\)</span> 에 대한 아핀 공간 <span class="math inline">\(\mathcal{E}_1 (E_1,\,\Theta_1),\,\mathcal{E}_2 (E_2,\,\Theta_2)\)</span> 를 생각하자. 데카르트곱 <span class="math inline">\(E_1 \times E_2\)</span> 은 벡터 공간이며 여기에 <span class="math inline">\(\Theta : (\mathcal{E}_1 \times \mathcal{E}_2) \times (\mathcal{E}_1 \times \mathcal{E}_2) \to E_1 \times E_2\)</span> 를</p>
<p><span class="math display">\[
\Theta ((A, B),\, (C,\,D)) = (\Theta_1(A, B),\, \Theta_2(C,\,D))
\]</span></p>
<p>로 정의한다면 <span class="math inline">\((\mathcal{E}_1 \times \mathcal{E}_2) (E_1 \times E_2,\, \Theta)\)</span> 는 아핀 공간이다.</p>
</div>
</div>
<p><br></p>
<div class="border" style="background-color:#FFF0F5 ;padding:5px;">
<div id="prp-AG_parallelogram_rule" class="theorem proposition">
<p><span class="theorem-title"><strong>명제 1.4 (평행사변형 규칙)</strong></span> 아핀 공간 <span class="math inline">\(\mathcal{E}\)</span> 와 <span class="math inline">\(A,\,B,\,C,\,D\in \mathcal{E}\)</span> 에 대해 다음이 성립한다.</p>
<p><span id="eq-AG_parallogram_rule"><span class="math display">\[
\overrightarrow{AB}=\overrightarrow{DC} \iff \overrightarrow{AD}=\overrightarrow{BC}.
\tag{1.1}\]</span></span></p>
<p>여기서 각각의 등식이 성립하는 사각형 <span class="math inline">\(AA'B'B\)</span> 를 <strong>평행사면형(paralleogram)</strong> 이라고 한다.</p>
</div>
</div>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span></p>
<div id="fig-AG_parallelogram_rule" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-AG_parallelogram_rule-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/parallelogram.png" class="img-fluid figure-img" width="200">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-AG_parallelogram_rule-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
그림&nbsp;1.2: 평행사변형 규칙
</figcaption>
</figure>
</div>
<p><span class="math inline">\(\overrightarrow{AB}=\overrightarrow{DC}\)</span> 이라면</p>
<p><span class="math display">\[
\overrightarrow{AD}=\overrightarrow{AB}+\overrightarrow{BC}+\overrightarrow{CD} = \overrightarrow{DC}  +\overrightarrow{BC}+\overrightarrow{CD} = \overrightarrow{BC}
\]</span></p>
<p>이다. 같은 방식으로 역을 증명 할 수 있다. <span class="math inline">\(\square\)</span></p>
</div>
<br>
<div class="border" style="background-color:#FFF0F5 ;padding:5px;">
<div id="prp-AG_addition_of_affine_and_vector" class="theorem proposition">
<p><span class="theorem-title"><strong>명제 1.5</strong></span> 아핀 공간 <span class="math inline">\(\mathcal{E}(E, \Theta)\)</span> 에 대해 <span class="math inline">\(A\in \mathcal{E},\, u\in E\)</span> 일 때 <span class="math inline">\(\overrightarrow{AB}=u\)</span> 를 만족하는 <span class="math inline">\(B\in \mathcal{E}\)</span> 가 유일하게 존재한다. 이 때 <span class="math inline">\(B=A+u\)</span> 라고 쓴다.</p>
</div>
</div>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span>see <a href="#exr-audin_1_47" class="quarto-xref">연습문제&nbsp;<span>1.7</span></a>.</p>
</div>
<p><br></p>
</section>
<section id="sec-AG_vectorization_and_subspace" class="level3" data-number="1.1.2">
<h3 data-number="1.1.2" class="anchored" data-anchor-id="sec-AG_vectorization_and_subspace"><span class="header-section-number">1.1.2</span> 아핀 공간의 벡터 공간화와 아핀 부분공간</h3>
<p><a href="#prp-AG_affile_space_2" class="quarto-xref">명제&nbsp;<span>1.2</span></a> 를 생각하자. 정해진 <span class="math inline">\(A\in \mathcal{E}\)</span> 에 대해 <span class="math inline">\(\Theta_A(\mathcal{E})=E\)</span> 인 벡터 공간이다.</p>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div id="def-AG_vectorialization" class="theorem definition">
<p><span class="theorem-title"><strong>정의 1.2 (벡터 공간화)</strong></span> 아핀 공간 <span class="math inline">\(\mathcal{E}\)</span> 의 한 점 <span class="math inline">\(A\in \mathcal{E}\)</span> 에 대해 아래와 같은 집합 <span class="math inline">\(\mathcal{E}_A\)</span> 를 <span class="math inline">\(\mathcal{E}\)</span> 의 <span class="math inline">\(A\)</span> 에 대한 벡터 공간 이라고 하며 이 과정을 <strong>벡터 공간화 (vectorialization)</strong> 이라고 한다.</p>
<p><span class="math display">\[
\mathcal{E}_A := \{\overrightarrow{AX} : X\in \mathcal{E}\} = \Theta_A(\mathcal{E}).
\]</span></p>
</div>
</div>
</div>
</div>
<p><br></p>
<p><a href="#exm-AG_affine_space_1" class="quarto-xref">보기&nbsp;<span>1.2</span></a> 에서 보았듯이 벡터 공간 <span class="math inline">\(E\)</span> 에 대해 자연스러운 아핀 구조가 존재한다. 그러나 이 아핀 공간에 대한 벡터 공간화는 원점이 되는 벡터의 선택에 따라 무수히 많기 때문에 아핀 공간에 대한 자연스러운 벡터 구조는 존재하지 않는다.</p>
<p><br></p>
<p>우리는 선형대수학에서 벡터 부분공간을 정의했다. 여기서는 아핀 부분공간을 정의하기로 하자.</p>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div id="def-AG_affine_subspace" class="theorem definition">
<p><span class="theorem-title"><strong>정의 1.3 (아핀 부분공간)</strong></span> 아핀 공간 <span class="math inline">\(\mathcal{E}(E,\,\Theta)\)</span> 에 대해 <span class="math inline">\(\mathcal{F}\subset \mathcal{E}\)</span> 가 공집합이거나, 어떤 <span class="math inline">\(A\subset \mathcal{E}\)</span> 에 대해 <span class="math inline">\(\Theta_A(\mathcal{F})\)</span> 가 <span class="math inline">\(E\)</span> 의 부분벡터 공간일 때 <span class="math inline">\(A\in \mathcal{F}\)</span> 이면 <span class="math inline">\(\mathcal{F}(\Theta_A(\mathcal{F}),\, \Theta)\)</span> 는 아핀 공간이며 <span class="math inline">\(\mathcal{E}\)</span> 의 <strong>아핀 부분공간(affine subspace)</strong> 이라고 한다.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<p><a href="#exm-AG_affine_space_0" class="quarto-xref">보기&nbsp;<span>1.1</span></a> 에서 보았듯이 공집합이라면 자명한 아핀 공간이기 때문에 더이상 고려할 것이 없다. 이제 공집합이 아닌 경우를 살펴 보자.</p>
<br>
<div class="border" style="background-color:#FFF0F5 ;padding:5px;">
<div id="lem-AG_existance_of_affine_subspace_1" class="theorem lemma">
<p><span class="theorem-title"><strong>보조정리 1.1</strong></span> <span class="math inline">\(\mathcal{F}\)</span> 가 아핀 공간 <span class="math inline">\(\mathcal{E}(E,\,\Theta)\)</span> 의 부분집합이며, 어떤 <span class="math inline">\(A\in \mathcal{F}\)</span> 에 대해 <span class="math inline">\(F=\Theta_A(\mathcal{F})\)</span> 가 <span class="math inline">\(E\)</span> 의 벡터 부분공간이라면 임의의 <span class="math inline">\(B\in \mathcal{F}\)</span> 에 대해서도 <span class="math inline">\(\Theta_B(\mathcal{F})=F\)</span> 이다.</p>
</div>
</div>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span>임의의 <span class="math inline">\(X\in \mathcal{F}\)</span> 에 대해 <span class="math inline">\(\overrightarrow{AX}\in F\)</span> 이다. <span class="math inline">\(\overrightarrow{BX}= \overrightarrow{BA} +\overrightarrow{AX}\)</span> 이며 <span class="math inline">\(\overrightarrow{BA},\, \overrightarrow{AX}\in F\)</span> 이고 <span class="math inline">\(F\)</span> 가 벡터 공간이므로 <span class="math inline">\(\overrightarrow{BX}\in F\)</span> 이다. 즉 <span class="math inline">\(\Theta_B(\mathcal{F}) \subset F\)</span> 이다. 임의의 <span class="math inline">\(v\in \Theta_A(\mathcal{F})\)</span> 에 대해 <span class="math inline">\(\overrightarrow{AY}=v\)</span> 인 <span class="math inline">\(Y\in \mathcal{F}\)</span> 가 존재한다. <span class="math inline">\(B\in \mathcal{F}\)</span> 이므로 <span class="math inline">\(\overrightarrow{AB}\in F\)</span> 이며 <span class="math inline">\(F\)</span> 가 벡터 공간이므로 <span class="math inline">\(\overrightarrow{AB}+\overrightarrow{AY}\in F=\Theta_A(\mathcal{F})\)</span> 이다. 즉 <span class="math inline">\(\overrightarrow{AB}+\overrightarrow{AY} = \overrightarrow{AX}\)</span> 인 <span class="math inline">\(X\in \mathcal{F}\)</span> 가 존재한다.</p>
<center>
<p><img src="images/affinespace2.png" class="img-fluid" width="200"></p>
</center>
<p><span class="math display">\[
\overrightarrow{BX} = \overrightarrow{BA}+\overrightarrow{AY}+\overrightarrow{YX}= -\overrightarrow{AX}+\overrightarrow{AY}+\overrightarrow{AY} + \overrightarrow{YA}+\overrightarrow{AX} = \overrightarrow{AY} = v
\]</span></p>
<p>이므로 <span class="math inline">\(v\in \Theta_B(\mathcal{F})\)</span> 이다. 즉 <span class="math inline">\(F\subset \Theta_B(\mathcal{F})\)</span> 이며 앞의 결과와 함께 <span class="math inline">\(\Theta_B(\mathcal{F})=F\)</span> 이다. <span class="math inline">\(\square\)</span></p>
</div>
<p><br></p>
<p>즉 <a href="#lem-AG_existance_of_affine_subspace_1" class="quarto-xref">보조정리&nbsp;<span>1.1</span></a> 에 의하면 일단 한 <span class="math inline">\(A\in \mathcal{E}\)</span> 에 대해 <span class="math inline">\(F=\Theta_A(\mathcal{F})\)</span> 가 벡터 공간이면 모든 <span class="math inline">\(X\in \mathcal{F}\)</span> 에 대해 <span class="math inline">\(\Theta_X(\mathcal{F}) = F\)</span> 므로 정의에 의해 <span class="math inline">\(\mathcal{F}\)</span> 는 아핀 공간이다. 이를 정리하면 다음과 같다.</p>
<div class="border" style="background-color:#FFF0F5 ;padding:5px;">
<div id="thm-AG_existance_of_affine_subspace_1" class="theorem">
<p><span class="theorem-title"><strong>정리 1.1</strong></span> 아핀 공간 <span class="math inline">\(\mathcal{E}(E,\,\Theta)\)</span> 에 대해 <span class="math inline">\(\mathcal{F}\subset\mathcal{E}\)</span> 일 때, 어떤 <span class="math inline">\(A\in \mathcal{F}\)</span> 에 대해 <span class="math inline">\(\Theta_A(\mathcal{F})\)</span> 가 <span class="math inline">\(E\)</span> 의 벡터 부분공간이면 <span class="math inline">\(\mathcal{F}(\Theta_A(\mathcal{F}),\,\Theta)\)</span> 는 <span class="math inline">\(\mathcal{E}\)</span> 의 아핀 부분공간이다.</p>
</div>
</div>
<p><br></p>
<p>아핀 공간의 부분집합으로부터 아핀부분집합이 되는 성질을 보였다. 이제 아핀 공간에 내재된 벡터 공간의 벡터 부분공간으로부터 아핀 부분공간을 구성하는 것을 알아보자.</p>
<div class="border" style="background-color:#FFF0F5 ;padding:5px;">
<div id="thm-AG_existance_of_affine_subspace_2" class="theorem">
<p><span class="theorem-title"><strong>정리 1.2</strong></span> 아핀 공간 <span class="math inline">\(\mathcal{E}(E,\,\Theta)\)</span> 에 대해 <span class="math inline">\(F\)</span> 가 <span class="math inline">\(E\)</span> 의 벡터 부분공간이며 <span class="math inline">\(A\in \mathcal{E}\)</span> 일 때, <span class="math inline">\(F\)</span> 를 내포하며 <span class="math inline">\(A\)</span> 를 지나는 아핀 부분공간이 유일하게 존재한다.</p>
</div>
</div>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span><span class="math inline">\(\mathcal{F}\subset \mathcal{E}\)</span> 를 다음과 같이 정하면 <span class="math inline">\(\mathcal{F}\)</span> 는 <span class="math inline">\(F\)</span> 를 내포하며 <span class="math inline">\(A\)</span> 를 지나는 <span class="math inline">\(\mathcal{E}\)</span> 의 아핀 부분공간이다.</p>
<p><span class="math display">\[
\mathcal{F} := \left\{X\in \mathcal{E} : \overrightarrow{AX}\in F\right\}.
\]</span></p>
<p>이제 <span class="math inline">\(\mathcal{F}'(F,\,\Theta)\)</span> 이 <span class="math inline">\(A\)</span> 를 지나는 아핀 공간이라고 하자. <span class="math inline">\(Y\in \mathcal{F}'\)</span> 이면 <span class="math inline">\(\overrightarrow{AY}\in F\)</span> 이며 따라서 <span class="math inline">\(Y\in \mathcal{F}\)</span> 이다. <span class="math inline">\(X\in \mathcal{F}\)</span> 이면 <span class="math inline">\(\overrightarrow{AX}\in F\)</span> 이며 따라서 <span class="math inline">\(X\in \mathcal{F}'\)</span> 이다. 즉 <span class="math inline">\(\mathcal{F}=\mathcal{F}'\)</span> 이다. <span class="math inline">\(\square\)</span></p>
</div>
<br>
<div class="border" style="background-color:#F2F4F4  ;padding:5px;">
<div id="exm-AG_affine_subspace_1" class="theorem example">
<p><span class="theorem-title"><strong>보기 1.4</strong></span> 모든 아핀 공간 <span class="math inline">\(\mathcal{E}\)</span> 의 점은 그 자체로 아핀 부분공간이다. 즉 아핀 공간의 0차원 부분공간은 점이다. <span class="math inline">\(0\)</span> 차원 벡터 공간은 영벡터로만 이루어진 벡터 공간이며, 따라서 영벡터에 해당하는 한 점으로만 이루어진 아핀 공간이다.</p>
</div>
</div>
<p><br></p>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div id="def-AG_line_and_plaine" class="theorem definition">
<p><span class="theorem-title"><strong>정의 1.4 (아핀 공간의 선과 평면)</strong></span> 아핀 공간의 1차원 부분공간을 <strong>선(line)</strong> 이라고 하고 아핀 공간의 2차원 부분공간을 <strong>평면(plaine)</strong> 이라고 한다.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<div class="border" style="background-color:#FFF0F5 ;padding:5px;">
<div id="prp-AG_affine_subspace_and_inverse_of_linear_mapping" class="theorem proposition">
<p><span class="theorem-title"><strong>명제 1.6</strong></span> 벡터 공간 <span class="math inline">\(F\)</span> 에 대해 <span class="math inline">\(f:E\to F\)</span> 가 선형사상이라고 하자. 이 때 <span class="math inline">\(v\in f(E)\)</span> 에 대해 <span class="math inline">\(f^{-1}(\{v\})\)</span> 는 <span class="math inline">\(\ker (f)\)</span> 가 내재된 <span class="math inline">\(E\)</span> 의 아핀 부분공간이다.</p>
</div>
</div>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span>벡터 공간에 내재된 아핀 공간에 대해서는 <a href="#exm-AG_affine_space_1" class="quarto-xref">보기&nbsp;<span>1.2</span></a> 를 참고하라. 정해진 <span class="math inline">\(v\in f(E)\)</span> 에 대해 <span class="math inline">\(E'=f^{-1}(\{v\})\)</span> 을 생각하자. 그리고 <span class="math inline">\(\theta:E'\times E' \to E\)</span> 를 <span class="math inline">\(\theta(x,\,y) := y-x\)</span> 로 정의하자. 정해진 <span class="math inline">\(x\in E'\)</span> 에 대해 <span class="math inline">\(\theta_x:E' \to E\)</span> 를 <span class="math inline">\(\theta_x(y):=\theta(x,\,y)\)</span> 라고 하면, <span class="math inline">\(\theta_x(E')= \ker (f)\)</span> 이며 치역을 <span class="math inline">\(\ker (E)\)</span> 로 제한한 <span class="math inline">\(\Theta : E' \times E' \to \ker (f)\)</span>, <span class="math inline">\(\Theta_u(v)= v-u\)</span> 는 전단사이며, <span class="math inline">\(\Theta\)</span> 는 샬 관계를 만족한다는 것을 보일 수 있다. 즉 <span class="math inline">\(f^{-1}(\{v\})(\ker (f),\, \Theta)\)</span> 는 <span class="math inline">\(E\)</span> 의 아핀 부분공간이다. <span class="math inline">\(\square\)</span></p>
</div>
<br>
<div class="border" style="background-color:#F2F4F4  ;padding:5px;">
<div id="exm-AG_affine_subspace_2" class="theorem example">
<p><span class="theorem-title"><strong>보기 1.5 (선형 시스템과 아핀 공간)</strong></span> 선형 시스템 <span class="math inline">\(A\boldsymbol{x}=\boldsymbol{b}\)</span> 의 해는 벡터 공간은 아니지만 아핀 공간이다. <span class="math inline">\(V=\{\boldsymbol{x}: A\boldsymbol{x}=\boldsymbol{0}\}\)</span> 는 벡터 공간이며 이 벡터 공간을 내포하는 아핀 공간이다. 또한 벡터 공간 <span class="math inline">\(E\)</span> 의 벡터 부분공간 <span class="math inline">\(F\)</span> 와 <span class="math inline">\(u_0\in E\)</span> 에 대해 <span class="math inline">\(F+u_0=\{f+u_0:f\in F\}\)</span> 역시 <span class="math inline">\(F\)</span> 를 내포하는 아핀 부분공간이다.</p>
</div>
</div>
<p><br></p>
</section>
<section id="sec-AG_set_properties_of_affine_space" class="level3" data-number="1.1.3">
<h3 data-number="1.1.3" class="anchored" data-anchor-id="sec-AG_set_properties_of_affine_space"><span class="header-section-number">1.1.3</span> 아핀 공간의 집합적 성질</h3>
<div class="border" style="background-color:#FFF0F5 ;padding:5px;">
<div id="prp-AG_intersection_of_affine_subspace" class="theorem proposition">
<p><span class="theorem-title"><strong>명제 1.7</strong></span> 아핀 부분공간의 교집합은 아핀 부분공간이다.</p>
</div>
</div>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span>아핀 공간 <span class="math inline">\(\mathcal{E}\)</span> 의 부분공간으로 이루어진 집합족 <span class="math inline">\(\{\mathcal{F}_i\}_{i \in I}\)</span> 에 대해 <span class="math inline">\(\mathcal{F}=\bigcap_{i\in I} \mathcal{F}_i\)</span> 라고 하자. <span class="math inline">\(\mathcal{F}=\varnothing\)</span> 일 경우는 자명하므로 공집합이 아닐 경우만 생각하자. <span class="math inline">\(F_i\)</span> 를 <span class="math inline">\(\mathcal{F}_i\)</span> 에 내재된 벡터 공간이라고 하면 <span class="math inline">\(F=\bigcap_{i\in I}F_i\)</span> 는 <span class="math inline">\(E\)</span> 의 벡터 부분공간이며 따라서 정해진 <span class="math inline">\(A\in \mathcal{F}\)</span> 를 포함하며 <span class="math inline">\(F\)</span> 를 내포하는 아핀 부분공간이 정해진다.</p>
</div>
<p><br></p>
<p>이로부터 다음 명제는 자명하다.</p>
<div class="border" style="background-color:#FFF0F5 ;padding:5px;">
<div id="prp-AG_smallest_affine_subspace_contains_a_subset" class="theorem proposition">
<p><span class="theorem-title"><strong>명제 1.8</strong></span> <span class="math inline">\(S\)</span> 가 <span class="math inline">\(\mathcal{E}\)</span> 의 부분집합일 때 <span class="math inline">\(S\)</span> 를 포함하는 모든 아핀 부분공간의 교집합은 <span class="math inline">\(S\)</span> 를 포함하는 가장 작은 아핀 부분공간이다.</p>
</div>
</div>
<p><br></p>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div id="def-AG_generation_of_affine_subspace" class="theorem definition">
<p><span class="theorem-title"><strong>정의 1.5 (아핀 공간의 생성)</strong></span> 아핀 공간 <span class="math inline">\(\mathcal{E}\)</span> 와 <span class="math inline">\(S \subset \mathcal{E}\)</span> 에 대해 <span class="math inline">\(S\)</span> 를 포함하는 가장 작은 아핀 부분공간을 <strong><span class="math inline">\(S\)</span> 에 의해 생성되는(혹은 전개되는) 아핀 공간</strong>이라고 하고 <span class="math inline">\(\langle S\rangle\)</span> 로 표기한다</p>
</div>
</div>
</div>
</div>
<br>
<div class="border" style="background-color:#FFF0F5 ;padding:5px;">
<div id="prp-AG_vector_space_of_generated_affine_space" class="theorem proposition">
<p><span class="theorem-title"><strong>명제 1.9</strong></span> <span class="math inline">\(S=\{A_0,\ldots,\,A_k\} \subset \mathcal{E}(E,\,\Theta)\)</span> 일 때 <span class="math inline">\(\langle S\rangle\)</span> 은 <span class="math inline">\(\{\overrightarrow{A_0A_1},\ldots,\,\overrightarrow{A_0A_k}\}\)</span> 에 의해 전개(span) 되는 벡터 공간을 내포한다. 이 경우 <span class="math inline">\(\langle S\rangle\)</span> 의 차원은 <span class="math inline">\(k\)</span> 보다 같거나 작다.</p>
</div>
</div>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span>벡터공간 <span class="math inline">\(F=\text{span}\left(\overrightarrow{A_0A_1},\ldots,\,\overrightarrow{A_0A_k}\right)\)</span> 를 내포하며 <span class="math inline">\(A_0\)</span> 를 지나는 아핀 공간이 <span class="math inline">\(\langle S \rangle\)</span> 임을 보이자. <span class="math inline">\(F\)</span> 가 <span class="math inline">\(E\)</span> 의 부분공간임은 자명하며 <a href="#thm-AG_existance_of_affine_subspace_2" class="quarto-xref">정리&nbsp;<span>1.2</span></a> 에 의해 <span class="math inline">\(F\)</span> 를 내포하고 <span class="math inline">\(A_0\)</span> 를 지나는 유일한 아핀공간 <span class="math inline">\(\mathcal{F}(F,\,\Theta)\)</span> 가 존재한다. <span class="math inline">\(A_0,\ldots,\,A_k\in \mathcal{F}\)</span> 이므로 <span class="math inline">\(\langle S \rangle \subset \mathcal{F}\)</span> 이다. 이제 <span class="math inline">\(X\in \mathcal{F}\)</span> 일 때 <span class="math inline">\(\overrightarrow{A_0X} \in F\)</span> 는 <span class="math inline">\(S\)</span> 를 포함하는 모든 아핀 공간에 포함되므로 <span class="math inline">\(X\in \langle S\rangle\)</span> 이다. 즉 <span class="math inline">\(\mathcal{F}\subset \langle S\rangle\)</span> 이다. 따라서 <span class="math inline">\(\mathcal{F}= \langle S\rangle\)</span> 이다. <span class="math inline">\(\dim(F) \le k\)</span> 이므로 <span class="math inline">\(\langle S\rangle\)</span> 의 차원은 <span class="math inline">\(k\)</span> 보다 작거나 같다.<span class="math inline">\(\square\)</span></p>
</div>
<p><br></p>
<p>아핀 공간의 합집합일 경우는 <a href="#exr-audin_1_4" class="quarto-xref">연습문제&nbsp;<span>1.3</span></a> 를 보라. 벡터 공간에서의 중요 성질인 선형독립과 같이 아핀 공간에서도 어떤 성분의 독립적 성질이 존재한다.</p>
<p><br></p>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div id="def-AG_affine_independency" class="theorem definition">
<p><span class="theorem-title"><strong>정의 1.6 (아핀독립)</strong></span> <span class="math inline">\(k+1\)</span> 개의 점 <span class="math inline">\(\{A_0,\ldots,\,A_k\}\)</span> 에 의해 생성되는 아핀 공간의 차원이 <span class="math inline">\(k\)</span> 일 때 <span class="math inline">\(\{A_0,\ldots,\,A_k\}\)</span> 가 <strong>아핀 독립(affine independent)</strong> 이라고 하며 이 때 <span class="math inline">\((A_0,\ldots,\,A_k)\)</span> 를 <span class="math inline">\(\mathcal{E}\)</span> 의 <strong>아핀 틀(affine frame)</strong> 이라고 한다.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<div class="border" style="background-color:#FFF0F5 ;padding:5px;">
<div id="prp-AG_linear_independence_and_affine_independence" class="theorem proposition">
<p><span class="theorem-title"><strong>명제 1.10</strong></span> <a href="#def-AG_affine_independency" class="quarto-xref">정의&nbsp;<span>1.6</span></a> 에서 <span class="math inline">\(\{A_0,\ldots,\,A_k\}\)</span> 가 아핀 독립일 필요충분조건은 <span class="math inline">\(\{\overrightarrow{A_0A_1},\ldots,\,\overrightarrow{A_0A_k}\}\)</span> 가 선형독립인 것이다.</p>
</div>
</div>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span><span class="math inline">\(\{A_0,\ldots,\,A_k\}\)</span> 가 아핀 독립 <span class="math inline">\(\iff \text{span}\left(\overrightarrow{A_0A_1},\ldots,\,\overrightarrow{A_0A_k}\right)\)</span> 이 <span class="math inline">\(k\)</span> 차원 벡터공간 <span class="math inline">\(\iff \{\overrightarrow{A_0A_1},\ldots,\,\overrightarrow{A_0A_k}\}\)</span> 가 선형독립. <span class="math inline">\(\square\)</span></p>
</div>
<p><br></p>
<div class="border" style="background-color:#F2F4F4  ;padding:5px;">
<div id="exm-AG_affine_frame_1" class="theorem example">
<p><span class="theorem-title"><strong>보기 1.6</strong></span> 직선에 대한 아핀 틀은 서로 다른 두 점이다(<a href="#exr-audin_1_3" class="quarto-xref">연습문제&nbsp;<span>1.2</span></a>). 따라서 아핀 공간 <span class="math inline">\(\mathcal{E}\)</span> 와 <span class="math inline">\(A,\,B\in \mathcal{E}\)</span> 에 대해 <span class="math inline">\(\langle A,\,B\rangle\)</span> 은 <span class="math inline">\(A,\,B\)</span> 를 잇는 직선이다.</p>
</div>
</div>
<p><br></p>
<div class="border" style="background-color:#F2F4F4  ;padding:5px;">
<div id="exm-AG_affine_frame_2" class="theorem example">
<p><span class="theorem-title"><strong>보기 1.7</strong></span> <span class="math inline">\(k+1\)</span> 개의 점이 독립일 필요충분조건은 각각의 점이 그 점을 제외한 다른 점들로 전개되는 부분공간에 포함되지 않는 것이다.(<a href="#exr-audin_1_6" class="quarto-xref">연습문제&nbsp;<span>1.5</span></a>)</p>
</div>
</div>
<p><br></p>
</section>
<section id="sec-AG_paralleism" class="level3" data-number="1.1.4">
<h3 data-number="1.1.4" class="anchored" data-anchor-id="sec-AG_paralleism"><span class="header-section-number">1.1.4</span> 아핀공간의 평행</h3>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div id="def-AG_pararrel_affine_subspace" class="theorem definition">
<p><span class="theorem-title"><strong>정의 1.7 (평행)</strong></span> 두 아핀 부분공간 <span class="math inline">\(\mathcal{F},\,\mathcal{G}\)</span> 가 내포하는 벡터 공간이 같을 때 두 아핀 부분공간은 <strong>평행하다(be parallel)</strong> 고 한다.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<p>두 아핀 부분공간의 교집합이 공집합이더라도 평행하지 않을 수 있다. 위의 정의에 의하면 3차원 공간에서 서로 만나지 않는 직선과 평면은 위의 정의에 의하면 평행하지 않다. 반대로 평면상에서 서로 만나지 않는 두 직선은 평행하다.</p>
<br>
<div class="border" style="background-color:#F2F4F4  ;padding:5px;">
<div id="exm-AG_affine_subspace_parallelism_1" class="theorem example">
<p><span class="theorem-title"><strong>보기 1.8</strong></span> <a href="#prp-AG_affine_subspace_and_inverse_of_linear_mapping" class="quarto-xref">명제&nbsp;<span>1.6</span></a> 를 보라. 벡터공간 <span class="math inline">\(E,\,F\)</span> 에서의 선형사상 <span class="math inline">\(f:E \to F\)</span> 를 생각하자. 각각의 <span class="math inline">\(v\in \text{im}(f)\)</span> 에 대해 <span class="math inline">\(f^{-1}(\{v\})\)</span> 는 모두 <span class="math inline">\(\ker (f)\)</span> 를 내포하는 평행하는 아핀부분공간이다.</p>
</div>
</div>
<p><br></p>
<div class="border" style="background-color:#FFF0F5 ;padding:5px;">
<div id="prp-AG_two_parallel_subspace" class="theorem proposition">
<p><span class="theorem-title"><strong>명제 1.11</strong></span> 두 아핀 부분공간 <span class="math inline">\(\mathcal{F},\,\mathcal{G}\)</span> 가 평행하다면 같거나 서로소이다.</p>
</div>
</div>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span><span class="math inline">\(A\in \mathcal{F}\cap \mathcal{G}\)</span> 라고 하자. <span class="math inline">\(E\)</span> 가 <span class="math inline">\(\mathcal{F},\,\mathcal{G}\)</span> 에 공통으로 내포된 벡터공간이라고 하면 <a href="#thm-AG_existance_of_affine_subspace_2" class="quarto-xref">정리&nbsp;<span>1.2</span></a> 에 의해 이 벡터공간은 유일하다. 따라서 <span class="math inline">\(\mathcal{F}=\mathcal{G}\)</span> 이다. <span class="math inline">\(\square\)</span></p>
</div>
<br>
<div class="border" style="background-color:#FFF0F5 ;padding:5px;">
<div id="thm-AG_parallel_axiom" class="theorem">
<p><span class="theorem-title"><strong>정리 1.3 (평행선 공리)</strong></span> 주어진 직선과 평행하며 정해진 점을 지나는 직선은 하나 뿐이다.</p>
</div>
</div>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span><span class="math inline">\(A\)</span> 를 지나며 1차원 공간 <span class="math inline">\(D\)</span> 를 내포하는 직선은 <a href="#thm-AG_existance_of_affine_subspace_2" class="quarto-xref">정리&nbsp;<span>1.2</span></a> 에 따라 하나 뿐이다.</p>
</div>
<p><br></p>
<br>
<div class="border" style="background-color:#FFF0F5 ;padding:5px;">
<div id="lem-AG_parallel_affine_space_1" class="theorem lemma">
<p><span class="theorem-title"><strong>보조정리 1.2</strong></span> <span class="math inline">\(\mathcal{F},\,\mathcal{G}\)</span> 가 아핀 공간 <span class="math inline">\(\mathcal{E}(E,\,\Theta)\)</span> 의 부분공간이며 각각 내포하는 벡터공간이 <span class="math inline">\(F,\,G\)</span> 라고 하자. <span class="math inline">\(A\in \mathcal{F},\, B\in \mathcal{G}\)</span> 일 때 다음이 성립한다.</p>
<p><span class="math display">\[
\mathcal{F}\cap \mathcal{G} \ne \varnothing\iff \overrightarrow{AB}\in F+G
\]</span></p>
</div>
</div>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span>(<span class="math inline">\(\implies\)</span>) <span class="math inline">\(X\in\mathcal{F}\cap \mathcal{G}\)</span> 이면 <span class="math inline">\(\overrightarrow{AX} \in F,\, \overrightarrow{BX}\in G\)</span> 이다. 따라서 <span class="math inline">\(\overrightarrow{AB}=\overrightarrow{AX}-\overrightarrow{BX} \in F+G\)</span> 이다.</p>
<p>(<span class="math inline">\(\impliedby\)</span>) <span class="math inline">\(\overrightarrow{AB}\in F+G\)</span> 이면 어떤 <span class="math inline">\(u\in F,\, v\in G\)</span> 에 대해 <span class="math inline">\(\overrightarrow{AB}=u+v\)</span> 이다. <span class="math inline">\(u=\overrightarrow{AX}\)</span> 가 되는 <span class="math inline">\(X\in \mathcal{F}\)</span> 에 대해 <span class="math inline">\(\overrightarrow{AB} = \overrightarrow{AX} +\overrightarrow{XB}\)</span> 이므로 <span class="math inline">\(v=\overrightarrow{XB}\in G\)</span> 이며 따라서 <span class="math inline">\(X\in \mathcal{G}\)</span> 이다. 즉 <span class="math inline">\(\mathcal{F}\cap \mathcal{G} \ne \varnothing\)</span> 이다. <span class="math inline">\(\square\)</span></p>
</div>
<br>
<div class="border" style="background-color:#FFF0F5 ;padding:5px;">
<div id="thm-AG_parallel_affine_space_2" class="theorem">
<p><span class="theorem-title"><strong>정리 1.4</strong></span> <span class="math inline">\(\mathcal{F},\, \mathcal{G}\)</span> 가 아핀 공간 <span class="math inline">\(\mathcal{E}(E,\,\Theta)\)</span> 의 부분공간이며, 각각이 내포하는 벡터공간을 <span class="math inline">\(F,\,G\)</span> 라고 하자. <span class="math inline">\(E=F+G\)</span> 이면 <span class="math inline">\(\mathcal{G}\)</span> 와 평행한 아핀 부분공간은 <span class="math inline">\(\mathcal{F}\)</span> 와의 교집합이 공집합이 아니다.</p>
</div>
</div>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span><span class="math inline">\(A\in \mathcal{F},\,B\in \mathcal{E}\)</span> 이고 <span class="math inline">\(\mathcal{G}'\)</span> 이 <span class="math inline">\(\mathcal{G}\)</span> 와 평행한 아핀 부분공간이라고 하자. <span class="math inline">\(\overrightarrow{AB} \in E =F+G\)</span> 이면 <a href="#lem-AG_parallel_affine_space_1" class="quarto-xref">보조정리&nbsp;<span>1.2</span></a> 에 따라 <span class="math inline">\(\mathcal{F}\cap \mathcal{G}'\ne \varnothing\)</span> 이다. <span class="math inline">\(\square\)</span></p>
</div>
<p><br></p>
</section>
</section>
<section id="아핀-사상" class="level2" data-number="1.2">
<h2 data-number="1.2" class="anchored" data-anchor-id="아핀-사상"><span class="header-section-number">1.2</span> 아핀 사상</h2>
<section id="sec-AG_affine_map" class="level3" data-number="1.2.1">
<h3 data-number="1.2.1" class="anchored" data-anchor-id="sec-AG_affine_map"><span class="header-section-number">1.2.1</span> 아핀 사상</h3>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div id="def-AG_affine_map" class="theorem definition">
<p><span class="theorem-title"><strong>정의 1.8 (아핀 사상)</strong></span> <span class="math inline">\(\mathcal{E},\,\mathcal{F}\)</span> 가 각각 <span class="math inline">\(E,\,F\)</span> 를 내포하는 아핀 공간일 때 함수 <span class="math inline">\(\varphi : \mathcal{E}\to \mathcal{F}\)</span> 에 대해 어떤 <span class="math inline">\(O\in \mathcal{E}\)</span> 와 선형 사상 <span class="math inline">\(\overrightarrow{\varphi}\in \mathcal{L}(E,\,F)\)</span> 가 존재하여</p>
<p><span class="math display">\[
\forall X\in \mathcal{E},\, \overrightarrow{\varphi}(\overrightarrow{OX}) = \overrightarrow{\varphi(O)\varphi(X)}
\]</span></p>
<p>일 때 <span class="math inline">\(\varphi\)</span> 를 <strong>아핀 사상(affine map)</strong> 이라고 한다.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<p>아핀 공간이 벡터공간과 함수와 같이 정의되듯이 아핀사상은 원점과 선형사상과 함께 정의된다.</p>
<p><br></p>
<div class="border" style="background-color:#FFF0F5 ;padding:5px;">
<div id="prp-AG_affine_map_1" class="theorem proposition">
<p><span class="theorem-title"><strong>명제 1.12</strong></span> 아핀 사상 <span class="math inline">\(\varphi\)</span> 의 선형 사상 <span class="math inline">\(f\)</span> 는 원점 <span class="math inline">\(O\)</span> 의 선택과는 무관하다. 즉 다른 원점 <span class="math inline">\(O'\)</span> 에 대해</p>
<p><span class="math display">\[
\overrightarrow{\varphi}(\overrightarrow{O'X}) = \overrightarrow{\varphi(O')\varphi(X)}
\]</span></p>
<p>이다.</p>
</div>
</div>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span><span class="math inline">\(\overrightarrow{\varphi}\)</span> 는 선형사상이므로 <span class="math inline">\(\overrightarrow{\varphi}(\overrightarrow{AB}) + \overrightarrow{\varphi}(\overrightarrow{AC})= \overrightarrow{\varphi}(\overrightarrow{BC})\)</span> 임을 이용한다. <span class="math display">\[
\begin{aligned}
\overrightarrow{\varphi(O')\varphi(X)} &amp;=  \overrightarrow{\varphi(O')\varphi(O)} + \overrightarrow{\varphi(O)\varphi(X)} = \overrightarrow{\varphi}(\overrightarrow{O'O}) + \overrightarrow{\varphi}(\overrightarrow{OX}) = \overrightarrow{\varphi}(\overrightarrow{O'X}). \qquad \square
\end{aligned}
\]</span></p>
</div>
<p><br></p>
</section>
</section>
<section id="연습문제" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="연습문제">연습문제</h2>
<div class="border" style="background-color:#F0FFFF  ;padding:5px;">
<div id="exr-audin_1_1" class="theorem exercise">
<p><span class="theorem-title"><strong>연습문제 1.1 (Audin 1.1)</strong></span> 평행사변형의 두 대각선은 서로 중점에서 만난다는 것을 보여라.</p>
</div>
</div>
<div class="proof solution">
<p><span class="proof-title"><em>(해답)</em>. </span><a href="#prp-AG_parallelogram_rule" class="quarto-xref">명제&nbsp;<span>1.4</span></a> 를 보자. 평행사변형 <span class="math inline">\(ABCD\)</span> 에서 <span class="math inline">\(\overrightarrow{AC}\)</span> 의 중점을 <span class="math inline">\(M\)</span>, <span class="math inline">\(\overrightarrow{BD}\)</span> 의 중점을 <span class="math inline">\(M'\)</span> 이라고 하자. 즉 <span class="math inline">\(\overrightarrow{AM}= \dfrac{1}{2}\overrightarrow{AC}\)</span> 이며 <span class="math inline">\(\overrightarrow{BM'}= \dfrac{1}{2}\overrightarrow{BD}\)</span> 이다.</p>
<p><span class="math display">\[
\begin{aligned}
\overrightarrow{MM'} &amp;= \overrightarrow{MA}+ \overrightarrow{AM'} = -\overrightarrow{AM} + \overrightarrow{AB} + \overrightarrow{BM'} \\[0.3em]
&amp;= - \dfrac{1}{2} \overrightarrow{AC} + \overrightarrow{AB} + \dfrac{1}{2}\overrightarrow{BD} = \dfrac{1}{2}\overrightarrow{CB} + \dfrac{1}{2}\overrightarrow{AD} = 0
\end{aligned}
\]</span></p>
</div>
<p><br></p>
<div class="border" style="background-color:#F0FFFF  ;padding:5px;">
<div id="exr-audin_1_3" class="theorem exercise">
<p><span class="theorem-title"><strong>연습문제 1.2 (Audin 1.3)</strong></span> 아핀 공간상의 두 점을 지나는 직선은 유일하다는 것을 증명하라.</p>
</div>
</div>
<div class="proof solution">
<p><span class="proof-title"><em>(해답)</em>. </span>아핀 공간 <span class="math inline">\(\mathcal{E}(E,\,\Theta)\)</span> 상의 두 점 <span class="math inline">\(A,\,B\in \mathcal{E}\)</span> 를 포함하는 1차원 아핀 부분공간 <span class="math inline">\(\mathcal{F}\)</span> 를 생각하자. <span class="math inline">\(\Theta_A(\mathcal{F})\)</span> 가 1차원 벡터 공간이며 <span class="math inline">\(B\in \mathcal{F}\)</span> 이므로 <span class="math inline">\(\Theta_A(\mathcal{F})\)</span> 는 <span class="math inline">\(\overrightarrow{AB}\)</span> 로 스팬되는 벡터 공간으로 유일하게 정해진다. 따라서 아핀 공간상의 <span class="math inline">\(A,\,B\)</span> 를 지나는 직선은 유일하다.</p>
</div>
<p><br></p>
<div class="border" style="background-color:#F0FFFF  ;padding:5px;">
<div id="exr-audin_1_4" class="theorem exercise">
<p><span class="theorem-title"><strong>연습문제 1.3 (Audin 1.4)</strong></span> <span class="math inline">\(\mathcal{F}_1,\,\mathcal{F}_2\)</span> 는 아핀 공간 <span class="math inline">\(\mathcal{E}\)</span> 의 두 아핀 부분공간이다. 어떤 조건에서 <span class="math inline">\(\mathcal{F}_1 \cup \mathcal{F}_2\)</span> 가 아핀 부분공간이 되는가?</p>
</div>
</div>
<div class="proof solution">
<p><span class="proof-title"><em>(해답)</em>. </span><span class="math inline">\(F_1,\,F_2\)</span> 를 각각 <span class="math inline">\(\mathcal{F}_1,\,\mathcal{F}_2\)</span> 에 내재하는 벡터 공간이라고 하자. 우리는 두 벡터 공간의 합집합이 벡터 공간일 필요충분조건은 두 벡터 공간중 하나가 다른 하나의 부분공간일 때라는 것을 안다. 따라서 한 아핀 공간이 다른 아핀 공간의 부분아핀 공간이어야 한다는 조건이 생기며 이 경우 두 아핀 공간의 합집합은 당연히 아핀 공간이다.</p>
</div>
<p><br></p>
<div class="border" style="background-color:#F0FFFF  ;padding:5px;">
<div id="exr-audin_1_5" class="theorem exercise">
<p><span class="theorem-title"><strong>연습문제 1.4 (Audin 1.5)</strong></span> 아핀 공간의 부분집합 <span class="math inline">\(\mathcal{F}\)</span> 가 아핀 부분공간일 필요충분조건은 임의의 <span class="math inline">\(A,\,B\in \mathcal{F}\)</span> 에 대해 <span class="math inline">\(\langle A,\,B\rangle \subset \mathcal{F}\)</span> 인 것임을 보여라.</p>
</div>
</div>
<div class="proof solution">
<p><span class="proof-title"><em>(해답)</em>. </span>아핀 공간 <span class="math inline">\(\mathcal{E}=\mathcal{E}(E,\,\Theta)\)</span> 에 대해 <span class="math inline">\(\mathcal{F}\subset\mathcal{E}\)</span> 라고 하자.</p>
<p>(<span class="math inline">\(\implies\)</span>) <span class="math inline">\(\mathcal{F}\)</span> 가 <span class="math inline">\(\mathcal{E}\)</span> 의 아핀 부분공간이고 <span class="math inline">\(A,\,B\in \mathcal{F}\)</span> 이며 <span class="math inline">\(\langle A,\,B\rangle\)</span> 은 <span class="math inline">\(A,\,B\)</span> 를 포함하는 모든 부분공간의 교집합이므로 <span class="math inline">\(\langle A,\,B\rangle \subset \mathcal{F}\)</span> 이다.</p>
<p>(<span class="math inline">\(\impliedby\)</span>) 임의의 <span class="math inline">\(A,\,B\in \mathcal{F}\)</span> 에 대해 <span class="math inline">\(\langle A,\,B\rangle \subset \mathcal{F}\)</span> 임을 가정하자. 임의의 <span class="math inline">\(A\in \mathcal{E}\)</span> 에 대해 <span class="math inline">\(F=\Theta_A(\mathcal{F})\)</span> 라고 하자. <span class="math inline">\(\overrightarrow{0}=\overrightarrow{AA}\in F\)</span> 이며 임의의 <span class="math inline">\(X\in \mathcal{F}\)</span> 에 대해 <span class="math inline">\(X\in \langle A,\,B\rangle\)</span> 이므로 <span class="math inline">\(-\overrightarrow{AX}\in F\)</span> 이다. 따라서 <span class="math inline">\(F\)</span> 가 벡터 공간이며, <a href="#thm-AG_existance_of_affine_subspace_2" class="quarto-xref">정리&nbsp;<span>1.2</span></a> 에 의해 <span class="math inline">\(\mathcal{F}\)</span> 는 <span class="math inline">\(\mathcal{E}\)</span> 의 부분공간이다.</p>
</div>
<p><br></p>
<div class="border" style="background-color:#F0FFFF  ;padding:5px;">
<div id="exr-audin_1_6" class="theorem exercise">
<p><span class="theorem-title"><strong>연습문제 1.5 (Audin 1.6)</strong></span> 아핀 공간상의 점 <span class="math inline">\(\{A_0,\ldots,\,A_k\}\)</span> 가 아핀 독립일 필요충분조건은 모든 <span class="math inline">\(i\in \{0,\ldots,\,k\}\)</span> 에 대해</p>
<p><span class="math display">\[
A_i \not\in \langle A_0,\ldots,\,A_{i-1},\,A_{i+1},\ldots,\,A_k\rangle
\]</span></p>
<p>임을 보여라.</p>
</div>
</div>
<div class="proof solution">
<p><span class="proof-title"><em>(해답)</em>. </span><a href="#prp-AG_affile_space_3" class="quarto-xref">명제&nbsp;<span>1.3</span></a> 로부터</p>
<p><span class="math display">\[
\begin{aligned}
X\in \langle A_0,\ldots,\,A_k\rangle &amp;\iff \overrightarrow{A_0X} \in \text{span}\left(\overrightarrow{A_0A_1},\ldots,\,\overrightarrow{A_0A_k}\right) \\
&amp;\iff \{\overrightarrow{A_0A_1},\ldots,\,\overrightarrow{A_0A_k},\, \overrightarrow{AX}\}\text{ 는 선형 종속} \\
&amp;\iff \{A_0,\ldots,\,A_k,\,X\} \text{ 는 아핀 독립이 아님.}
\end{aligned}
\]</span></p>
<p>임을 안다.</p>
</div>
<p><br></p>
<div class="border" style="background-color:#F0FFFF  ;padding:5px;">
<div id="exr-audin_1_7" class="theorem exercise">
<p><span class="theorem-title"><strong>연습문제 1.6 (Audin 1.7)</strong></span> 아핀 공간상의 점 <span class="math inline">\(\{A_0,\ldots,\,A_k\}\)</span> 가 아핀 독립일 필요충분조건은 모든 <span class="math inline">\(i\in \{0,\ldots,\,k\}\)</span> 에 대해</p>
<p><span class="math display">\[
A_i \not\in \langle A_0,\ldots,\,A_{i-1}\rangle
\]</span></p>
<p>임을 보여라.</p>
</div>
</div>
<div class="proof solution">
<p><span class="proof-title"><em>(해답)</em>. </span>(<span class="math inline">\(\implies\)</span>) <span class="math inline">\(i&lt;k\)</span> 에 대해 <span class="math inline">\(\langle A_0,\ldots,\,A_{i}\rangle\)</span> 은 <span class="math inline">\(\langle A_0,\ldots,\,A_k\rangle\)</span> 의 아핀부분공간이므로 <a href="#exr-audin_1_6" class="quarto-xref">연습문제&nbsp;<span>1.5</span></a> 에 따라 성립한다.</p>
<p>(<span class="math inline">\(\impliedby\)</span>) <span class="math inline">\(A_k \not\in \langle A_0,\,\ldots,\,A_{k-1}\rangle\)</span> 이므로 <span class="math inline">\(\{A_0,\ldots,\,A_k\}\)</span> 는 아핀 독립이다.</p>
</div>
<p><br></p>
<div class="border" style="background-color:#F0FFFF  ;padding:5px;">
<div id="exr-audin_1_47" class="theorem exercise">
<p><span class="theorem-title"><strong>연습문제 1.7 (Audin 1.47)</strong></span> 아핀 공간 <span class="math inline">\(\mathcal{E}(E,\,\Theta)\)</span> 를 생각하자. 함수 <span class="math inline">\(\phi:E\times \mathcal{E} \to \mathcal{E}\)</span> 를 다음과 같이 정의한다.</p>
<p><span class="math display">\[
\phi(M,\, u) = M+u
\]</span></p>
<p>이 때 <span class="math inline">\(M'=\phi(M,\,u)\)</span> 일 때 <span class="math inline">\(\overrightarrow{MM'}= u\)</span> 이다.</p>
</div>
</div>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "복사완료!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "복사완료!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../../src/part1/part1.html" class="pagination-link" aria-label="기하학">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">기하학</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../../src/references.html" class="pagination-link" aria-label="references.html">
        <span class="nav-page-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">references.html</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>